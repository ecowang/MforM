<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 3 Statistical Modeling | 读Modern Statistics for Modern Biology随记</title>
  <meta name="description" content="学习Modern Statistics for Modern Biology记录" />
  <meta name="generator" content="bookdown 0.13 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 3 Statistical Modeling | 读Modern Statistics for Modern Biology随记" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="学习Modern Statistics for Modern Biology记录" />
  <meta name="github-repo" content="ecowang/M for M" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 3 Statistical Modeling | 读Modern Statistics for Modern Biology随记" />
  
  <meta name="twitter:description" content="学习Modern Statistics for Modern Biology记录" />
  

<meta name="author" content="王强" />


<meta name="date" content="2019-09-15" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="intro.html"/>
<link rel="next" href="high-quality-graphics-in-r.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">读Modern Statistics for Modern Biology随记</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction 引言</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#section-1.1"><i class="fa fa-check"></i><b>1.1</b> 缘起</a></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#section-1.2"><i class="fa fa-check"></i><b>1.2</b> 原书目标</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#section-1.3"><i class="fa fa-check"></i><b>1.3</b> 统计江湖的套路</a></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#section-1.4"><i class="fa fa-check"></i><b>1.4</b> 统计的常见概念和生命学科特殊性</a><ul>
<li class="chapter" data-level="1.4.1" data-path="index.html"><a href="index.html#-p--n"><i class="fa fa-check"></i><b>1.4.1</b> 关于 <em>p</em> 和 <em>n</em></a></li>
<li class="chapter" data-level="1.4.2" data-path="index.html"><a href="index.html#section-1.4.2"><i class="fa fa-check"></i><b>1.4.2</b> 一个普通的建模</a></li>
<li class="chapter" data-level="1.4.3" data-path="index.html"><a href="index.html#-p--n-"><i class="fa fa-check"></i><b>1.4.3</b> 生命学科的大 <em>p</em> 小 <em>n</em> 问题</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="index.html"><a href="index.html#section-1.5"><i class="fa fa-check"></i><b>1.5</b> 原书中主要内容</a></li>
<li class="chapter" data-level="1.6" data-path="index.html"><a href="index.html#section-1.6"><i class="fa fa-check"></i><b>1.6</b> 需要的计算机技能</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>2</b> Generative Models for Discrete Data 广义模型和离散数据</a><ul>
<li class="chapter" data-level="2.1" data-path="intro.html"><a href="intro.html#section-2.1"><i class="fa fa-check"></i><b>2.1</b> 本章概述</a></li>
<li class="chapter" data-level="2.2" data-path="intro.html"><a href="intro.html#section-2.2"><i class="fa fa-check"></i><b>2.2</b> 回顾一点概率论与数理统计</a></li>
<li class="chapter" data-level="2.3" data-path="intro.html"><a href="intro.html#section-2.3"><i class="fa fa-check"></i><b>2.3</b> 生命科学一些基础知识（直接看图）</a></li>
<li class="chapter" data-level="2.4" data-path="intro.html"><a href="intro.html#section-2.4"><i class="fa fa-check"></i><b>2.4</b> 本章大体框架</a></li>
<li class="chapter" data-level="2.5" data-path="intro.html"><a href="intro.html#section-2.5"><i class="fa fa-check"></i><b>2.5</b> 泊松分布</a></li>
<li class="chapter" data-level="2.6" data-path="intro.html"><a href="intro.html#r"><i class="fa fa-check"></i><b>2.6</b> 荡开一会看R语言的函数</a></li>
<li class="chapter" data-level="2.7" data-path="intro.html"><a href="intro.html#a-generative-model-for-epitope-detection"><i class="fa fa-check"></i><b>2.7</b> 应用一个表位检测模型（a generative model for epitope detection）</a></li>
<li class="chapter" data-level="2.8" data-path="intro.html"><a href="intro.html#multinomial-distribution"><i class="fa fa-check"></i><b>2.8</b> 多项分布（Multinomial distribution）</a></li>
<li class="chapter" data-level="2.9" data-path="intro.html"><a href="intro.html#power"><i class="fa fa-check"></i><b>2.9</b> 多项分布的权重（power）</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="statistical-modeling.html"><a href="statistical-modeling.html"><i class="fa fa-check"></i><b>3</b> Statistical Modeling</a><ul>
<li class="chapter" data-level="3.1" data-path="statistical-modeling.html"><a href="statistical-modeling.html#section-3.1"><i class="fa fa-check"></i><b>3.1</b> 统计和概率模型的区别</a></li>
<li class="chapter" data-level="3.2" data-path="statistical-modeling.html"><a href="statistical-modeling.html#section-3.2"><i class="fa fa-check"></i><b>3.2</b> 一个简单的统计建模</a><ul>
<li class="chapter" data-level="3.2.1" data-path="statistical-modeling.html"><a href="statistical-modeling.html#section-3.2.1"><i class="fa fa-check"></i><b>3.2.1</b> 这就是经典数据的经典统计？</a></li>
<li class="chapter" data-level="3.2.2" data-path="statistical-modeling.html"><a href="statistical-modeling.html#section-3.2.2"><i class="fa fa-check"></i><b>3.2.2</b> 讲到了一点回归分析</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="statistical-modeling.html"><a href="statistical-modeling.html#section-3.3"><i class="fa fa-check"></i><b>3.3</b> 二元分布和极大似然率</a><ul>
<li class="chapter" data-level="3.3.1" data-path="statistical-modeling.html"><a href="statistical-modeling.html#section-3.3.1"><i class="fa fa-check"></i><b>3.3.1</b> 可能性就是概率，概率就是可能性的概率</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="statistical-modeling.html"><a href="statistical-modeling.html#section-3.4"><i class="fa fa-check"></i><b>3.4</b> 多元数据</a></li>
<li class="chapter" data-level="3.5" data-path="statistical-modeling.html"><a href="statistical-modeling.html#-chi2-distribution"><i class="fa fa-check"></i><b>3.5</b> 卡方分布 （<span class="math inline">\(\chi^2 distribution\)</span>）</a></li>
<li class="chapter" data-level="3.6" data-path="statistical-modeling.html"><a href="statistical-modeling.html#chargaffs-rul"><i class="fa fa-check"></i><b>3.6</b> 查格夫定律（Chargaff’s Rul）</a></li>
<li class="chapter" data-level="3.7" data-path="statistical-modeling.html"><a href="statistical-modeling.html#section-3.7"><i class="fa fa-check"></i><b>3.7</b> 贝叶斯方法</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="high-quality-graphics-in-r.html"><a href="high-quality-graphics-in-r.html"><i class="fa fa-check"></i><b>4</b> High-Quality Graphics in R</a><ul>
<li class="chapter" data-level="4.1" data-path="intro.html"><a href="intro.html#r"><i class="fa fa-check"></i><b>4.1</b> R作图基操</a></li>
<li class="chapter" data-level="4.2" data-path="high-quality-graphics-in-r.html"><a href="high-quality-graphics-in-r.html#ggplot2"><i class="fa fa-check"></i><b>4.2</b> 一个数据实例，引入ggplot2</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="mixture-models.html"><a href="mixture-models.html"><i class="fa fa-check"></i><b>5</b> Mixture Models</a></li>
<li class="chapter" data-level="6" data-path="clustering.html"><a href="clustering.html"><i class="fa fa-check"></i><b>6</b> Clustering</a></li>
<li class="chapter" data-level="7" data-path="testing.html"><a href="testing.html"><i class="fa fa-check"></i><b>7</b> Testing</a></li>
<li class="chapter" data-level="8" data-path="multivariate-analysis.html"><a href="multivariate-analysis.html"><i class="fa fa-check"></i><b>8</b> Multivariate Analysis</a></li>
<li class="chapter" data-level="9" data-path="high-throughput-count-data.html"><a href="high-throughput-count-data.html"><i class="fa fa-check"></i><b>9</b> High-Throughput Count Data</a></li>
<li class="chapter" data-level="10" data-path="multivariate-methods-for-heterogeneous-data.html"><a href="multivariate-methods-for-heterogeneous-data.html"><i class="fa fa-check"></i><b>10</b> Multivariate Methods for Heterogeneous Data</a></li>
<li class="chapter" data-level="11" data-path="networks-and-trees.html"><a href="networks-and-trees.html"><i class="fa fa-check"></i><b>11</b> Networks and Trees</a></li>
<li class="chapter" data-level="12" data-path="image-data.html"><a href="image-data.html"><i class="fa fa-check"></i><b>12</b> Image Data</a></li>
<li class="chapter" data-level="13" data-path="supervised-learning.html"><a href="supervised-learning.html"><i class="fa fa-check"></i><b>13</b> Supervised Learning</a></li>
<li class="chapter" data-level="14" data-path="design-of-high-throughput-experiments-and-their-analyses.html"><a href="design-of-high-throughput-experiments-and-their-analyses.html"><i class="fa fa-check"></i><b>14</b> Design of High-Throughput Experiments and Their Analyses</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/ecowang/MforM" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">读Modern Statistics for Modern Biology随记</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="statistical-modeling" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Statistical Modeling</h1>
<p>前一章的基本思路是已知这个数据符合某分布，在这个前提下，看出现特定值是否合理。但实际情况中不可能提供给研究者完美的符合某分布的数据，总是乱糟糟一团过来，然后看着分析去吧。如果要确定这个数据的统计学特征，需要从数据本身出发进行推断，这个过程即统计推论（statistical inference）。本章主要介绍这个过程。</p>
<p>原书中列出本章目标如下：</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>明确概率（probability）和统计(statistics)的区别。</li>
<li>应用直方图/矩形图/条形图（histograms），以及其他可视化工具，拟合数据到某分布。</li>
<li>通过数据模拟，使用极大似然率（maximum likehood）方法进行统计推论。</li>
<li>基于有预知信息的数据进行统计推论。这里将使用贝叶斯方法，引入新的特定分布。我们同样还会使用数据模拟，观察贝叶斯方法和极大似然率方法的差异。</li>
<li>使用统计模型和估测，计算（evaluate）二元分布和多元分布的依赖性。</li>
<li>分析一些历史上有趣的基因数据，数据以表格形式组织。</li>
<li>针对<strong>因变量数据（dependent data）</strong>应用马尔科夫链。</li>
<li>在基因组数据中做一些计数导向的练习，学习操作基因组数据的Bioconductor类型数据。</li>
</ol>
</blockquote>
<div id="section-3.1" class="section level2">
<h2><span class="header-section-number">3.1</span> 统计和概率模型的区别</h2>
<p>前一章的统计模型，是已知数据所符合的分布，通过分布的参数，求出一个“事件（event）”的可能。如在表位一例中，已知数据符合 <span class="math inline">\(\lambda = 0.5\)</span> 的泊松分布，然后可以求得发生次数大于等于7的事件概率为 <span class="math inline">\(10^{-4}\)</span> 。 这里泊松分布就是已知的原假设。</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-29"></span>
<img src="http://web.stanford.edu/class/bios221/book/images/ProbaDiagram.png" alt="已知分布，求某一事件概率" width="30%" />
<p class="caption">
Figure 3.1: 已知分布，求某一事件概率
</p>
</div>
<p>但实际上，得到的数据未必预先知道符合什么分布，比如有时你就是测出一堆蛋白或者基因序列来。这种时候，可能就需要倒过来计算，看看这些数据符合什么分布（概率模型 <em>F</em>），并求得分布模型的参数，这个过程就是统计推论。</p>
</div>
<div id="section-3.2" class="section level2">
<h2><span class="header-section-number">3.2</span> 一个简单的统计建模</h2>
<p>建模首先要看数据符合什么分布。分布有很多，二项分布、多项分布、泊松分布，这是对离散变量的，正态分布、指数分布等，是针对连续变量的。有时候变量过于复杂，一种分布难以涵盖其特点，也会用混合模型来拟合，这个第四章会讲到。</p>
<p>还是看上一章用过的表位数据，这次假设提前不知道分布。并且先把极值去掉。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">load</span>(<span class="st">&quot;data/e100.RData&quot;</span>) <span class="co"># 100个数，0、1。。。最大是7.</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2">e99 =<span class="st"> </span>e100[<span class="op">-</span><span class="kw">which.max</span>(e100)] <span class="co"># 把最大的去掉（只剩下0、1、2了）</span></a></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">table</span>(e99)</a></code></pre></div>
<pre><code>## e99
##  0  1  2 
## 58 34  7</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">barplot</span>(<span class="kw">table</span>(e99), <span class="dt">space =</span> <span class="fl">0.8</span>)</a></code></pre></div>
<p><img src="M-for-M_files/figure-html/unnamed-chunk-31-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>要看数据是否符合某分布，原书介绍了一种拟合优度检验图（goodness-of-fit diagram）的方法，叫他娘的什么根图（<a href="https://www.fromthebottomoftheheap.net/2016/06/07/rootograms/">rootogram</a>），这方法是2016年提出来的，还没有经过时间的历练，而且是否符合分布这样的工作，实际工作中很少遇到，稍微看看就行了。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">library</span>(<span class="st">&quot;vcd&quot;</span>) <span class="co"># 需要这个包。</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2">gf1 =<span class="st"> </span><span class="kw">goodfit</span>(e99, <span class="st">&quot;poisson&quot;</span>) <span class="co"># goodfit这个函数，拟合数据。</span></a>
<a class="sourceLine" id="cb47-3" data-line-number="3"><span class="kw">rootogram</span>(gf1) <span class="co"># rootogram作图，红点是理论分布所在的位置，然后把实际数上提或者下压。</span></a></code></pre></div>
<p><img src="M-for-M_files/figure-html/unnamed-chunk-32-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>越符合分布，差别的越小。看来这99个数提的压的都不多，还算符合泊松分布，下一步就是估计分布的参数，这里就是<span class="math inline">\(\lambda\)</span>。</p>
<p>估计<span class="math inline">\(\lambda\)</span>的方法就是通过数据计算最接近的<span class="math inline">\(\hat\lambda\)</span>，这叫极大似然估计（maximum likelihood estimator, MLE）。当然可以通过一系列 <code>rpois(100, 1)、rpois(100, 2)、rpois(100, 3)。。。</code>来看到底哪个更符合，但首先这样工作量很大，其次<span class="math inline">\(\lambda\)</span>的值可以是小数，不一定试多少次，实际通过数学变换可以做的更优雅一点。</p>
<p>计算当泊松分布<span class="math inline">\(\lambda = m\)</span>时，见到e100这个数据的概率。</p>
<p><span class="math display">\[\begin{equation*}
\begin{aligned}
P(58 \times 0,
  34 \times 1,
  7 \times 2,
  \text{one }7 \;|\; \text{data are Poisson}(m)) =
P(0)^{58}\times
P(1)^{34}\times
P(2)^{7}\times
P(7)^{1}.\end{aligned}
\end{equation*}\]</span></p>
<p>当<span class="math inline">\(\lambda = 3\)</span> 时，<span class="math inline">\(P(0) = dpois(0, lambda = 3)\)</span>。利用向量计算特性，可以这样计算：</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">prod</span>(<span class="kw">dpois</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">7</span>), <span class="dt">lambda =</span><span class="dv">3</span>) <span class="op">^</span><span class="st"> </span>(<span class="kw">c</span>(<span class="dv">58</span>, <span class="dv">34</span>, <span class="dv">7</span>, <span class="dv">1</span>)))</a></code></pre></div>
<pre><code>## [1] 1.392143e-110</code></pre>
<p>这个可能性就叫<span class="math inline">\(\lambda\)</span>的似然函数（likelihood function），公式写作，注意这个连乘符号<span class="math inline">\(\prod\)</span>，其公式写法和连加符号<span class="math inline">\(\sum\)</span>基本一致：</p>
<p><span class="math display">\[\begin{equation*}
L\left(\lambda ,\,\ x=(k_1,k_2,k_3,...)\right) = \prod_{i=1}^{100} f(k_i)
\end{equation*}\]</span></p>
<p>鉴于里面连乘的数都太小，取log后再计算会比较容易，对手算和电脑都是如此。当log后，m满足这个公式取值最大的时候，m就是<span class="math inline">\(\hat \lambda\)</span>。 可以按如下方式进行模拟。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" data-line-number="1">loglikelihood =<span class="st"> </span><span class="cf">function</span>(lambda, <span class="dt">data =</span> e100) {</a>
<a class="sourceLine" id="cb50-2" data-line-number="2">  <span class="kw">sum</span>(<span class="kw">log</span>(<span class="kw">dpois</span>(data, lambda)))</a>
<a class="sourceLine" id="cb50-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb50-4" data-line-number="4"></a>
<a class="sourceLine" id="cb50-5" data-line-number="5">lambdas =<span class="st"> </span><span class="kw">seq</span>(<span class="fl">0.05</span>, <span class="fl">0.95</span>, <span class="dt">length =</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb50-6" data-line-number="6"></a>
<a class="sourceLine" id="cb50-7" data-line-number="7">loglik =<span class="st"> </span><span class="kw">vapply</span>(lambdas, loglikelihood, <span class="kw">numeric</span>(<span class="dv">1</span>)) <span class="co">#后面这个numeric（1）是对返回结果的控制，就要1个数字，其实这里没必要，因为loglikelihood只返回一个数字，但作为参数必须写上。</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8"></a>
<a class="sourceLine" id="cb50-9" data-line-number="9"><span class="kw">plot</span>(lambdas, loglik, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">lwd =</span> <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb50-10" data-line-number="10">     <span class="dt">xlab =</span> <span class="kw">expression</span>(lambda))</a>
<a class="sourceLine" id="cb50-11" data-line-number="11">m0 =<span class="st"> </span><span class="kw">mean</span>(e100)   <span class="co"># 为啥平均值就是要找的点？</span></a>
<a class="sourceLine" id="cb50-12" data-line-number="12"><span class="kw">abline</span>(<span class="dt">v =</span> m0, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb50-13" data-line-number="13"><span class="kw">abline</span>(<span class="dt">h =</span> <span class="kw">loglikelihood</span>(m0), <span class="dt">col =</span> <span class="st">&quot;purple&quot;</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</a></code></pre></div>
<p><img src="M-for-M_files/figure-html/unnamed-chunk-34-1.png" width="60%" style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1">m0</a></code></pre></div>
<pre><code>## [1] 0.55</code></pre>
<p>实际上使用vcd包里的goodfit函数，也能计算出来，轮子已经制造好了。</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" data-line-number="1">gf =<span class="st"> </span><span class="kw">goodfit</span>(e100, <span class="st">&quot;poisson&quot;</span>)</a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="kw">names</span>(gf) <span class="co"># 拟合后的结果很丰富，是个list格式数据。</span></a></code></pre></div>
<pre><code>## [1] &quot;observed&quot; &quot;count&quot;    &quot;fitted&quot;   &quot;type&quot;     &quot;method&quot;   &quot;df&quot;      
## [7] &quot;par&quot;</code></pre>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" data-line-number="1">gf<span class="op">$</span>par <span class="co"># par应该是parameter的缩写，泊松函数只有一个par，其他可能有更多。</span></a></code></pre></div>
<pre><code>## $lambda
## [1] 0.55</code></pre>
<p>如果使用0.55 重新做上一章的表位检测例题，还是有些不同的。</p>
<table>
<thead>
<tr class="header">
<th>频率</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>按0.5</td>
<td>9</td>
<td>23254</td>
<td>60529</td>
<td>14528</td>
<td>1531</td>
<td>141</td>
<td>8</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>按0.55</td>
<td>3</td>
<td>15416</td>
<td>62606</td>
<td>19239</td>
<td>2508</td>
<td>209</td>
<td>17</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>下面解释前面的疑惑：为什么<code>mean（e100）</code>能使似然率最大？</p>
<p><span class="math display">\[\begin{align}
\log L(\lambda, x)=&amp;\sum_{i=1}^{100} -\lambda +k_i \log\lambda-\log (k_i!)  \\
=&amp;-100\lambda +\log\lambda\left(\sum_{i=1}^{100} k_i\right)  + \text{const.} 
\end{align}\]</span></p>
<p>要求得能使上面函数取最大值的<span class="math inline">\(\lambda\)</span>，我们对 <span class="math inline">\(\lambda\)</span> 求导（derivative），使之成为0。</p>
<p><span class="math display">\[\begin{align}
\frac{d}{d\lambda}\log L=&amp;-100 +\frac{1}{\lambda}\sum_{i=1}^{100} k_i
\stackrel{?}{=}0  \\
\lambda=&amp;\frac{1}{100}\sum_{i=1}^{100} k_i=\bar{k}  
\end{align}\]</span></p>
<p>由此求得，当<span class="math inline">\(\lambda = \bar k\)</span> 的时候，函数取值最大。这一段是已知分布，推断参数，还有一类问题是求那种分布最合适，属于拟合优度（goodness of fit）的问题，后面会涉及。</p>
<div id="section-3.2.1" class="section level3">
<h3><span class="header-section-number">3.2.1</span> 这就是经典数据的经典统计？</h3>
<p>经典统计检验框架下，只考虑一个模型，称数据的原假设（null model）。这种只考虑一个模型的原假设，不管具体数据出自哪个处理，哪个组别，统统认为是出自同一分布的随机数据。这样一来，分析者只能跟检验这些数是否真的出自这个模型、按这个模型出现这些数的概率有多少之类的问题较劲，没有别的分析方向。如果符合一个模型了，比如泊松分布，我们就能知道出现某个异常值的概率到底是多小。</p>
</div>
<div id="section-3.2.2" class="section level3">
<h3><span class="header-section-number">3.2.2</span> 讲到了一点回归分析</h3>
<p>对一般的连续变量回归模型 <span class="math inline">\(y = ax+b + e\)</span>， 要求a和b，残差（residuals）e的要符合正态分布，还能估算这个分布的变异（variance）。</p>
<p>对离散变量（count data），也可以应用回归模型，但残差分布不是正态的，需要应用广义线性模型（generalized linear models）。第八章、第九章中分别对RNA序列、下一代测序数据和16SrRNA数据应用该分析。</p>
</div>
</div>
<div id="section-3.3" class="section level2">
<h2><span class="header-section-number">3.3</span> 二元分布和极大似然率</h2>
<p>遇到的二元分布实际数据经常是n个事件（trials），结果已知但不知道成功概率是多少，要去估算。比如知道扔了120次硬币，10次正面朝上，则可以估计概率<span class="math inline">\(\hat{p}=\frac{1}{12}\)</span>。也可以按概率从小到大挨个试试。</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb57-1" data-line-number="1">probs  =<span class="st">  </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="fl">0.3</span>, <span class="dt">by =</span> <span class="fl">0.005</span>) <span class="co"># 从0到0.3，每0.005一个。</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2">likelihood =<span class="st"> </span><span class="kw">dbinom</span>(<span class="dv">10</span>, <span class="dt">prob =</span> probs, <span class="dt">size =</span> <span class="dv">120</span>) </a>
<a class="sourceLine" id="cb57-3" data-line-number="3"><span class="kw">plot</span>(probs, likelihood, <span class="dt">pch =</span> <span class="dv">16</span>, <span class="dt">xlab =</span> <span class="st">&quot;probability of success&quot;</span>,</a>
<a class="sourceLine" id="cb57-4" data-line-number="4">       <span class="dt">ylab =</span> <span class="st">&quot;likelihood&quot;</span>, <span class="dt">cex=</span><span class="fl">0.6</span>)</a></code></pre></div>
<p><img src="M-for-M_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1">probs[<span class="kw">which.max</span>(likelihood)]</a></code></pre></div>
<pre><code>## [1] 0.085</code></pre>
<p>差球不多，在0.005精度下，是最接近<span class="math inline">\(\frac{1}{12}\)</span>的了。不明白为啥要这么搞一遍，可能为了让更加熟悉函数吧。</p>
<div id="section-3.3.1" class="section level3">
<h3><span class="header-section-number">3.3.1</span> 可能性就是概率，概率就是可能性的概率</h3>
<p>一方面，在给定参数的条件下，概率分布能告诉我们见到特定数据的可能性是多少；另一方面，当数据确定时，我们去寻求最可能出现这些数据的分布。</p>
<p>如300次观测，40次成功。按排列组合计算，</p>
<p><span class="math display">\[\begin{equation}
f(\theta\,|\,300,40) = f(40\,|\,300,\theta)={300 \choose 40} \, \theta^{40} \, (1-\theta)^{(300-40)}.
\tag{2.5}
\end{equation}\]</span></p>
<p>两边log后，得：</p>
<p><span class="math display">\[\begin{equation*}
\log f(\theta |y) = 115 + 40\log(\theta)+(300-40)\log(1-\theta).
\end{equation*}\]</span></p>
<p>按这个做个函数，然后作图。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" data-line-number="1">loglikelihood =<span class="st"> </span><span class="cf">function</span>(theta, <span class="dt">n =</span> <span class="dv">300</span>, <span class="dt">k =</span> <span class="dv">40</span>) {</a>
<a class="sourceLine" id="cb60-2" data-line-number="2">  <span class="dv">115</span> <span class="op">+</span><span class="st"> </span>k <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(theta) <span class="op">+</span><span class="st"> </span>(n <span class="op">-</span><span class="st"> </span>k) <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>theta)</a>
<a class="sourceLine" id="cb60-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb60-4" data-line-number="4"></a>
<a class="sourceLine" id="cb60-5" data-line-number="5">thetas =<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">by =</span> <span class="fl">0.001</span>) <span class="co"># 一串串概率试一试</span></a>
<a class="sourceLine" id="cb60-6" data-line-number="6"></a>
<a class="sourceLine" id="cb60-7" data-line-number="7"><span class="kw">plot</span>(thetas, <span class="kw">loglikelihood</span>(thetas), <span class="dt">xlab =</span> <span class="kw">expression</span>(theta),</a>
<a class="sourceLine" id="cb60-8" data-line-number="8">  <span class="dt">ylab =</span> <span class="kw">expression</span>(<span class="kw">paste</span>(<span class="st">&quot;log f(&quot;</span>, theta, <span class="st">&quot; | y)&quot;</span>)),<span class="dt">type =</span> <span class="st">&quot;l&quot;</span>)</a></code></pre></div>
<p><img src="M-for-M_files/figure-html/unnamed-chunk-37-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>发现虽然40/300=0.13333最合适，但还有一段一直到0.2左右，都能出现最大可能。这一特性将会在后面的贝叶斯方法中见到。</p>
</div>
</div>
<div id="section-3.4" class="section level2">
<h2><span class="header-section-number">3.4</span> 多元数据</h2>
<p>对DNA的组成，AG嘌呤，CT嘧啶，四种碱基构成多元数据。这里用<code>Bioconductor</code>包的函数，读取一段真正的DNA序列，是金黄葡萄球菌（Staphylococcus aureus）的fasta格式数据。</p>
<p>安装需要这样：</p>
<blockquote>
<p>if (!requireNamespace(“BiocManager”, quietly = TRUE))
install.packages(“BiocManager”)</p>
</blockquote>
<blockquote>
<p>BiocManager::install(“Biostrings”)</p>
</blockquote>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="kw">library</span>(<span class="st">&quot;Biostrings&quot;</span>)</a>
<a class="sourceLine" id="cb61-2" data-line-number="2">staph =<span class="st"> </span><span class="kw">readDNAStringSet</span>(<span class="st">&quot;data/staphsequence.ffn.txt&quot;</span>, <span class="st">&quot;fasta&quot;</span>)</a></code></pre></div>
<p>折腾了这么久，终于见到真的数据了。。。可以看看数据结构，是2650条DNA序列，主体是一串串的ATGC字母，有名字，有宽度。可以用函数看看各碱基出现频率。</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="kw">letterFrequency</span>(staph[[<span class="dv">1</span>]], <span class="dt">letters =</span> <span class="st">&quot;ATGC&quot;</span>, <span class="dt">OR =</span><span class="dv">0</span>)</a></code></pre></div>
<pre><code>##   A   T   G   C 
## 522 392 229 219</code></pre>
<p>为什么用[[]]，不用[]？因为[[]]表示的火车这节车厢里面的货物，[]表示的是这节车厢。</p>
<p>然后进入有意义的问题——通过对比前十个基因的碱基出现频率是否一致，来推断其遗传特征是否相同。</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb64-1" data-line-number="1">letterFrq =<span class="st"> </span><span class="kw">vapply</span>(staph, letterFrequency, <span class="dt">FUN.VALUE =</span> <span class="kw">numeric</span>(<span class="dv">4</span>), </a>
<a class="sourceLine" id="cb64-2" data-line-number="2">                   <span class="dt">letters =</span> <span class="st">&quot;ATGC&quot;</span>, <span class="dt">OR =</span> <span class="dv">0</span>)    <span class="co"># 计算各基因碱基频率,并处理好从哪个基因出来的。</span></a>
<a class="sourceLine" id="cb64-3" data-line-number="3"><span class="kw">colnames</span>(letterFrq) =<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;gene&quot;</span>, <span class="kw">seq</span>(<span class="dt">along =</span> staph)) <span class="co"># 4行、2650列，一列是一个基因。</span></a>
<a class="sourceLine" id="cb64-4" data-line-number="4">letterFrq[,<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>] <span class="co">#查看下前10列</span></a></code></pre></div>
<pre><code>##   gene1 gene2 gene3 gene4 gene5 gene6 gene7 gene8 gene9 gene10
## A   522   413    85   411   685   887   275   510   487    191
## T   392   352    74   327   531   793   250   445   357    252
## G   229   193    56   207   423   586   169   316   263    142
## C   219   176    31   168   293   395   137   244   180    111</code></pre>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb66-1" data-line-number="1">tab10 =<span class="st"> </span>letterFrq[, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>] <span class="co"># 这就是前10个基因，ATGC各有多少个</span></a>
<a class="sourceLine" id="cb66-2" data-line-number="2">computeProportions =<span class="st"> </span><span class="cf">function</span>(x) {x<span class="op">/</span><span class="kw">sum</span>(x)} <span class="co"># 构造个函数，大概为了下一步好用apply。</span></a>
<a class="sourceLine" id="cb66-3" data-line-number="3">prop10 =<span class="st"> </span><span class="kw">apply</span>(tab10, <span class="dv">2</span>, computeProportions) <span class="co"># 对列计算比例，即对每个基因计算碱基比例。</span></a>
<a class="sourceLine" id="cb66-4" data-line-number="4"><span class="kw">round</span>(prop10, <span class="dt">digits =</span> <span class="dv">2</span>)  <span class="co"># 取两位小数</span></a></code></pre></div>
<pre><code>##   gene1 gene2 gene3 gene4 gene5 gene6 gene7 gene8 gene9 gene10
## A  0.38  0.36  0.35  0.37  0.35  0.33  0.33  0.34  0.38   0.27
## T  0.29  0.31  0.30  0.29  0.27  0.30  0.30  0.29  0.28   0.36
## G  0.17  0.17  0.23  0.19  0.22  0.22  0.20  0.21  0.20   0.20
## C  0.16  0.16  0.13  0.15  0.15  0.15  0.16  0.16  0.14   0.16</code></pre>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb68-1" data-line-number="1">p0 =<span class="st"> </span><span class="kw">rowMeans</span>(prop10)</a>
<a class="sourceLine" id="cb68-2" data-line-number="2">p0</a></code></pre></div>
<pre><code>##         A         T         G         C 
## 0.3470531 0.2999714 0.2011442 0.1518313</code></pre>
<p>后面又通过蒙特卡洛检验这10个基因碱基含量的合理性。略。</p>
</div>
<div id="-chi2-distribution" class="section level2">
<h2><span class="header-section-number">3.5</span> 卡方分布 （<span class="math inline">\(\chi^2 distribution\)</span>）</h2>
<p>基本统计，卡方检验可以替代复杂的模拟，介绍了一些应用。</p>
</div>
<div id="chargaffs-rul" class="section level2">
<h2><span class="header-section-number">3.6</span> 查格夫定律（Chargaff’s Rul）</h2>
<p>来自任何生物体的任何细胞的DNA应该具有1：1的嘧啶和嘌呤碱基比例，更具体地说，鸟嘌呤的量应该等于胞嘧啶，并且腺嘌呤的量应该等于胸腺嘧啶。这种模式存在于DNA的两条链中。它们是由奥地利出生的化学家Erwin Chargaff 在20世纪40年代后期发现提出的。</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="kw">load</span>(<span class="st">&quot;data/ChargaffTable.RData&quot;</span>)</a>
<a class="sourceLine" id="cb70-2" data-line-number="2">ChargaffTable</a></code></pre></div>
<pre><code>##                   A    T    C    G
## Human-Thymus   30.9 29.4 19.9 19.8
## Mycobac.Tuber  15.1 14.6 34.9 35.4
## Chicken-Eryth. 28.8 29.2 20.5 21.5
## Sheep-liver    29.3 29.3 20.5 20.7
## Sea Urchin     32.8 32.1 17.7 17.3
## Wheat          27.3 27.1 22.7 22.8
## Yeast          31.3 32.9 18.7 17.1
## E.coli         24.7 23.6 26.0 25.7</code></pre>
</div>
<div id="section-3.7" class="section level2">
<h2><span class="header-section-number">3.7</span> 贝叶斯方法</h2>
<p>待续。。。</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="intro.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="high-quality-graphics-in-r.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/ecowang/MforM/edit/master/02-Statiscal.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"download": ["M-for-M.pdf", "M-for-M.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
